/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 32.19.0 Wed May 22 20:54:00 2019.
 */

#include <string.h>

#include "motor_can.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint32_t unpack_left_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static inline uint32_t unpack_right_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) >> shift);
}

int motor_can_left_id_info_pack(
    uint8_t *dst_p,
    const struct motor_can_left_id_info_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->tritium_id, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->tritium_id, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->tritium_id, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->tritium_id, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->serial_number, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->serial_number, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->serial_number, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(src_p->serial_number, 24u, 0xffu);

    return (8);
}

int motor_can_left_id_info_unpack(
    struct motor_can_left_id_info_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->tritium_id |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->tritium_id |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->tritium_id |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->tritium_id |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->serial_number |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->serial_number |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dst_p->serial_number |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dst_p->serial_number |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);

    return (0);
}

uint32_t motor_can_left_id_info_tritium_id_encode(double value)
{
    return (uint32_t)(value);
}

double motor_can_left_id_info_tritium_id_decode(uint32_t value)
{
    return ((double)value);
}

bool motor_can_left_id_info_tritium_id_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

uint32_t motor_can_left_id_info_serial_number_encode(double value)
{
    return (uint32_t)(value);
}

double motor_can_left_id_info_serial_number_decode(uint32_t value)
{
    return ((double)value);
}

bool motor_can_left_id_info_serial_number_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int motor_can_left_status_pack(
    uint8_t *dst_p,
    const struct motor_can_left_status_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->limit_flag_bridge_pwm, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->limit_flag_motor_current, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->limit_flag_velocity, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->limit_flag_bus_current, 3u, 0x08u);
    dst_p[0] |= pack_left_shift_u8(src_p->limit_flag_bus_voltage_upper_limit, 4u, 0x10u);
    dst_p[0] |= pack_left_shift_u8(src_p->limit_flag_bus_voltage_lower_limit, 5u, 0x20u);
    dst_p[0] |= pack_left_shift_u8(src_p->limit_flag_heatsink_temperature, 6u, 0x40u);
    dst_p[2] |= pack_left_shift_u8(src_p->error_flag_hw_overcurrent, 0u, 0x01u);
    dst_p[2] |= pack_left_shift_u8(src_p->error_flag_sw_overcurrent, 1u, 0x02u);
    dst_p[2] |= pack_left_shift_u8(src_p->error_flag_dc_bus_overvoltage, 2u, 0x04u);
    dst_p[2] |= pack_left_shift_u8(src_p->error_flag_motor_position_hall_sequence, 3u, 0x08u);
    dst_p[2] |= pack_left_shift_u8(src_p->error_flag_watchdog, 4u, 0x10u);
    dst_p[2] |= pack_left_shift_u8(src_p->error_flag_config_read, 5u, 0x20u);
    dst_p[2] |= pack_left_shift_u8(src_p->error_flag15_v_undervoltage, 6u, 0x40u);
    dst_p[4] |= pack_left_shift_u16(src_p->active_motor, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->active_motor, 8u, 0xffu);

    return (8);
}

int motor_can_left_status_unpack(
    struct motor_can_left_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->limit_flag_bridge_pwm |= unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->limit_flag_motor_current |= unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->limit_flag_velocity |= unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->limit_flag_bus_current |= unpack_right_shift_u8(src_p[0], 3u, 0x08u);
    dst_p->limit_flag_bus_voltage_upper_limit |= unpack_right_shift_u8(src_p[0], 4u, 0x10u);
    dst_p->limit_flag_bus_voltage_lower_limit |= unpack_right_shift_u8(src_p[0], 5u, 0x20u);
    dst_p->limit_flag_heatsink_temperature |= unpack_right_shift_u8(src_p[0], 6u, 0x40u);
    dst_p->error_flag_hw_overcurrent |= unpack_right_shift_u8(src_p[2], 0u, 0x01u);
    dst_p->error_flag_sw_overcurrent |= unpack_right_shift_u8(src_p[2], 1u, 0x02u);
    dst_p->error_flag_dc_bus_overvoltage |= unpack_right_shift_u8(src_p[2], 2u, 0x04u);
    dst_p->error_flag_motor_position_hall_sequence |= unpack_right_shift_u8(src_p[2], 3u, 0x08u);
    dst_p->error_flag_watchdog |= unpack_right_shift_u8(src_p[2], 4u, 0x10u);
    dst_p->error_flag_config_read |= unpack_right_shift_u8(src_p[2], 5u, 0x20u);
    dst_p->error_flag15_v_undervoltage |= unpack_right_shift_u8(src_p[2], 6u, 0x40u);
    dst_p->active_motor |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->active_motor |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);

    return (0);
}

uint8_t motor_can_left_status_limit_flag_bridge_pwm_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_left_status_limit_flag_bridge_pwm_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_left_status_limit_flag_bridge_pwm_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_left_status_limit_flag_motor_current_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_left_status_limit_flag_motor_current_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_left_status_limit_flag_motor_current_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_left_status_limit_flag_velocity_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_left_status_limit_flag_velocity_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_left_status_limit_flag_velocity_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_left_status_limit_flag_bus_current_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_left_status_limit_flag_bus_current_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_left_status_limit_flag_bus_current_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_left_status_limit_flag_bus_voltage_upper_limit_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_left_status_limit_flag_bus_voltage_upper_limit_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_left_status_limit_flag_bus_voltage_upper_limit_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_left_status_limit_flag_bus_voltage_lower_limit_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_left_status_limit_flag_bus_voltage_lower_limit_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_left_status_limit_flag_bus_voltage_lower_limit_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_left_status_limit_flag_heatsink_temperature_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_left_status_limit_flag_heatsink_temperature_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_left_status_limit_flag_heatsink_temperature_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_left_status_error_flag_hw_overcurrent_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_left_status_error_flag_hw_overcurrent_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_left_status_error_flag_hw_overcurrent_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_left_status_error_flag_sw_overcurrent_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_left_status_error_flag_sw_overcurrent_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_left_status_error_flag_sw_overcurrent_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_left_status_error_flag_dc_bus_overvoltage_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_left_status_error_flag_dc_bus_overvoltage_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_left_status_error_flag_dc_bus_overvoltage_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_left_status_error_flag_motor_position_hall_sequence_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_left_status_error_flag_motor_position_hall_sequence_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_left_status_error_flag_motor_position_hall_sequence_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_left_status_error_flag_watchdog_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_left_status_error_flag_watchdog_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_left_status_error_flag_watchdog_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_left_status_error_flag_config_read_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_left_status_error_flag_config_read_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_left_status_error_flag_config_read_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_left_status_error_flag15_v_undervoltage_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_left_status_error_flag15_v_undervoltage_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_left_status_error_flag15_v_undervoltage_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint16_t motor_can_left_status_active_motor_encode(double value)
{
    return (uint16_t)(value);
}

double motor_can_left_status_active_motor_decode(uint16_t value)
{
    return ((double)value);
}

bool motor_can_left_status_active_motor_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int motor_can_left_bus_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_left_bus_measurement_t *src_p,
    size_t size)
{
    uint32_t bus_current;
    uint32_t bus_voltage;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&bus_voltage, &src_p->bus_voltage, sizeof(bus_voltage));
    dst_p[0] |= pack_left_shift_u32(bus_voltage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(bus_voltage, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(bus_voltage, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(bus_voltage, 24u, 0xffu);
    memcpy(&bus_current, &src_p->bus_current, sizeof(bus_current));
    dst_p[4] |= pack_left_shift_u32(bus_current, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(bus_current, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(bus_current, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(bus_current, 24u, 0xffu);

    return (8);
}

int motor_can_left_bus_measurement_unpack(
    struct motor_can_left_bus_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t bus_current;
    uint32_t bus_voltage;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    bus_voltage = 0u;
    bus_voltage |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    bus_voltage |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    bus_voltage |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    bus_voltage |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->bus_voltage, &bus_voltage, sizeof(dst_p->bus_voltage));
    bus_current = 0u;
    bus_current |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    bus_current |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    bus_current |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    bus_current |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->bus_current, &bus_current, sizeof(dst_p->bus_current));

    return (0);
}

float motor_can_left_bus_measurement_bus_voltage_encode(double value)
{
    return (float)(value);
}

double motor_can_left_bus_measurement_bus_voltage_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_bus_measurement_bus_voltage_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_left_bus_measurement_bus_current_encode(double value)
{
    return (float)(value);
}

double motor_can_left_bus_measurement_bus_current_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_bus_measurement_bus_current_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_left_velocity_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_left_velocity_measurement_t *src_p,
    size_t size)
{
    uint32_t motor_velocity;
    uint32_t vehicle_velocity;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&motor_velocity, &src_p->motor_velocity, sizeof(motor_velocity));
    dst_p[0] |= pack_left_shift_u32(motor_velocity, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(motor_velocity, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(motor_velocity, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(motor_velocity, 24u, 0xffu);
    memcpy(&vehicle_velocity, &src_p->vehicle_velocity, sizeof(vehicle_velocity));
    dst_p[4] |= pack_left_shift_u32(vehicle_velocity, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(vehicle_velocity, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(vehicle_velocity, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(vehicle_velocity, 24u, 0xffu);

    return (8);
}

int motor_can_left_velocity_measurement_unpack(
    struct motor_can_left_velocity_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t motor_velocity;
    uint32_t vehicle_velocity;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    motor_velocity = 0u;
    motor_velocity |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    motor_velocity |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    motor_velocity |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    motor_velocity |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->motor_velocity, &motor_velocity, sizeof(dst_p->motor_velocity));
    vehicle_velocity = 0u;
    vehicle_velocity |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    vehicle_velocity |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    vehicle_velocity |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    vehicle_velocity |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->vehicle_velocity, &vehicle_velocity, sizeof(dst_p->vehicle_velocity));

    return (0);
}

float motor_can_left_velocity_measurement_motor_velocity_encode(double value)
{
    return (float)(value);
}

double motor_can_left_velocity_measurement_motor_velocity_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_velocity_measurement_motor_velocity_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_left_velocity_measurement_vehicle_velocity_encode(double value)
{
    return (float)(value);
}

double motor_can_left_velocity_measurement_vehicle_velocity_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_velocity_measurement_vehicle_velocity_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_left_phase_current_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_left_phase_current_measurement_t *src_p,
    size_t size)
{
    uint32_t phase_current_a;
    uint32_t phase_current_b;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&phase_current_b, &src_p->phase_current_b, sizeof(phase_current_b));
    dst_p[0] |= pack_left_shift_u32(phase_current_b, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(phase_current_b, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(phase_current_b, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(phase_current_b, 24u, 0xffu);
    memcpy(&phase_current_a, &src_p->phase_current_a, sizeof(phase_current_a));
    dst_p[4] |= pack_left_shift_u32(phase_current_a, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(phase_current_a, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(phase_current_a, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(phase_current_a, 24u, 0xffu);

    return (8);
}

int motor_can_left_phase_current_measurement_unpack(
    struct motor_can_left_phase_current_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t phase_current_a;
    uint32_t phase_current_b;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    phase_current_b = 0u;
    phase_current_b |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    phase_current_b |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    phase_current_b |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    phase_current_b |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->phase_current_b, &phase_current_b, sizeof(dst_p->phase_current_b));
    phase_current_a = 0u;
    phase_current_a |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    phase_current_a |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    phase_current_a |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    phase_current_a |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->phase_current_a, &phase_current_a, sizeof(dst_p->phase_current_a));

    return (0);
}

float motor_can_left_phase_current_measurement_phase_current_b_encode(double value)
{
    return (float)(value);
}

double motor_can_left_phase_current_measurement_phase_current_b_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_phase_current_measurement_phase_current_b_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_left_phase_current_measurement_phase_current_a_encode(double value)
{
    return (float)(value);
}

double motor_can_left_phase_current_measurement_phase_current_a_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_phase_current_measurement_phase_current_a_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_left_motor_voltage_vector_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_left_motor_voltage_vector_measurement_t *src_p,
    size_t size)
{
    uint32_t vd;
    uint32_t vq;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&vq, &src_p->vq, sizeof(vq));
    dst_p[0] |= pack_left_shift_u32(vq, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(vq, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(vq, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(vq, 24u, 0xffu);
    memcpy(&vd, &src_p->vd, sizeof(vd));
    dst_p[4] |= pack_left_shift_u32(vd, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(vd, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(vd, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(vd, 24u, 0xffu);

    return (8);
}

int motor_can_left_motor_voltage_vector_measurement_unpack(
    struct motor_can_left_motor_voltage_vector_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t vd;
    uint32_t vq;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    vq = 0u;
    vq |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    vq |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    vq |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    vq |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->vq, &vq, sizeof(dst_p->vq));
    vd = 0u;
    vd |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    vd |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    vd |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    vd |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->vd, &vd, sizeof(dst_p->vd));

    return (0);
}

float motor_can_left_motor_voltage_vector_measurement_vq_encode(double value)
{
    return (float)(value);
}

double motor_can_left_motor_voltage_vector_measurement_vq_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_motor_voltage_vector_measurement_vq_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_left_motor_voltage_vector_measurement_vd_encode(double value)
{
    return (float)(value);
}

double motor_can_left_motor_voltage_vector_measurement_vd_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_motor_voltage_vector_measurement_vd_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_left_motor_current_vector_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_left_motor_current_vector_measurement_t *src_p,
    size_t size)
{
    uint32_t id;
    uint32_t iq;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&iq, &src_p->iq, sizeof(iq));
    dst_p[0] |= pack_left_shift_u32(iq, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(iq, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(iq, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(iq, 24u, 0xffu);
    memcpy(&id, &src_p->id, sizeof(id));
    dst_p[4] |= pack_left_shift_u32(id, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(id, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(id, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(id, 24u, 0xffu);

    return (8);
}

int motor_can_left_motor_current_vector_measurement_unpack(
    struct motor_can_left_motor_current_vector_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t id;
    uint32_t iq;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    iq = 0u;
    iq |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    iq |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    iq |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    iq |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->iq, &iq, sizeof(dst_p->iq));
    id = 0u;
    id |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    id |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    id |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    id |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->id, &id, sizeof(dst_p->id));

    return (0);
}

float motor_can_left_motor_current_vector_measurement_iq_encode(double value)
{
    return (float)(value);
}

double motor_can_left_motor_current_vector_measurement_iq_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_motor_current_vector_measurement_iq_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_left_motor_current_vector_measurement_id_encode(double value)
{
    return (float)(value);
}

double motor_can_left_motor_current_vector_measurement_id_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_motor_current_vector_measurement_id_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_left_motor_back_emf_measurement_prediction_pack(
    uint8_t *dst_p,
    const struct motor_can_left_motor_back_emf_measurement_prediction_t *src_p,
    size_t size)
{
    uint32_t bem_fd;
    uint32_t bem_fq;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&bem_fq, &src_p->bem_fq, sizeof(bem_fq));
    dst_p[0] |= pack_left_shift_u32(bem_fq, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(bem_fq, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(bem_fq, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(bem_fq, 24u, 0xffu);
    memcpy(&bem_fd, &src_p->bem_fd, sizeof(bem_fd));
    dst_p[4] |= pack_left_shift_u32(bem_fd, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(bem_fd, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(bem_fd, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(bem_fd, 24u, 0xffu);

    return (8);
}

int motor_can_left_motor_back_emf_measurement_prediction_unpack(
    struct motor_can_left_motor_back_emf_measurement_prediction_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t bem_fd;
    uint32_t bem_fq;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    bem_fq = 0u;
    bem_fq |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    bem_fq |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    bem_fq |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    bem_fq |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->bem_fq, &bem_fq, sizeof(dst_p->bem_fq));
    bem_fd = 0u;
    bem_fd |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    bem_fd |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    bem_fd |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    bem_fd |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->bem_fd, &bem_fd, sizeof(dst_p->bem_fd));

    return (0);
}

float motor_can_left_motor_back_emf_measurement_prediction_bem_fq_encode(double value)
{
    return (float)(value);
}

double motor_can_left_motor_back_emf_measurement_prediction_bem_fq_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_motor_back_emf_measurement_prediction_bem_fq_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_left_motor_back_emf_measurement_prediction_bem_fd_encode(double value)
{
    return (float)(value);
}

double motor_can_left_motor_back_emf_measurement_prediction_bem_fd_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_motor_back_emf_measurement_prediction_bem_fd_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_left_voltage_rail15_v1_v65_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_left_voltage_rail15_v1_v65_measurement_t *src_p,
    size_t size)
{
    uint32_t reference1_v65;
    uint32_t supply15_v;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&reference1_v65, &src_p->reference1_v65, sizeof(reference1_v65));
    dst_p[0] |= pack_left_shift_u32(reference1_v65, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(reference1_v65, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(reference1_v65, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(reference1_v65, 24u, 0xffu);
    memcpy(&supply15_v, &src_p->supply15_v, sizeof(supply15_v));
    dst_p[4] |= pack_left_shift_u32(supply15_v, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(supply15_v, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(supply15_v, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(supply15_v, 24u, 0xffu);

    return (8);
}

int motor_can_left_voltage_rail15_v1_v65_measurement_unpack(
    struct motor_can_left_voltage_rail15_v1_v65_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t reference1_v65;
    uint32_t supply15_v;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    reference1_v65 = 0u;
    reference1_v65 |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    reference1_v65 |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    reference1_v65 |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    reference1_v65 |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->reference1_v65, &reference1_v65, sizeof(dst_p->reference1_v65));
    supply15_v = 0u;
    supply15_v |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    supply15_v |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    supply15_v |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    supply15_v |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->supply15_v, &supply15_v, sizeof(dst_p->supply15_v));

    return (0);
}

float motor_can_left_voltage_rail15_v1_v65_measurement_reference1_v65_encode(double value)
{
    return (float)(value);
}

double motor_can_left_voltage_rail15_v1_v65_measurement_reference1_v65_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_voltage_rail15_v1_v65_measurement_reference1_v65_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_left_voltage_rail15_v1_v65_measurement_supply15_v_encode(double value)
{
    return (float)(value);
}

double motor_can_left_voltage_rail15_v1_v65_measurement_supply15_v_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_voltage_rail15_v1_v65_measurement_supply15_v_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_left_voltage_rail2_v51_v2_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_left_voltage_rail2_v51_v2_measurement_t *src_p,
    size_t size)
{
    uint32_t supply1_v2;
    uint32_t supply2_v5;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&supply1_v2, &src_p->supply1_v2, sizeof(supply1_v2));
    dst_p[0] |= pack_left_shift_u32(supply1_v2, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(supply1_v2, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(supply1_v2, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(supply1_v2, 24u, 0xffu);
    memcpy(&supply2_v5, &src_p->supply2_v5, sizeof(supply2_v5));
    dst_p[4] |= pack_left_shift_u32(supply2_v5, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(supply2_v5, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(supply2_v5, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(supply2_v5, 24u, 0xffu);

    return (8);
}

int motor_can_left_voltage_rail2_v51_v2_measurement_unpack(
    struct motor_can_left_voltage_rail2_v51_v2_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t supply1_v2;
    uint32_t supply2_v5;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    supply1_v2 = 0u;
    supply1_v2 |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    supply1_v2 |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    supply1_v2 |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    supply1_v2 |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->supply1_v2, &supply1_v2, sizeof(dst_p->supply1_v2));
    supply2_v5 = 0u;
    supply2_v5 |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    supply2_v5 |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    supply2_v5 |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    supply2_v5 |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->supply2_v5, &supply2_v5, sizeof(dst_p->supply2_v5));

    return (0);
}

float motor_can_left_voltage_rail2_v51_v2_measurement_supply1_v2_encode(double value)
{
    return (float)(value);
}

double motor_can_left_voltage_rail2_v51_v2_measurement_supply1_v2_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_voltage_rail2_v51_v2_measurement_supply1_v2_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_left_voltage_rail2_v51_v2_measurement_supply2_v5_encode(double value)
{
    return (float)(value);
}

double motor_can_left_voltage_rail2_v51_v2_measurement_supply2_v5_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_voltage_rail2_v51_v2_measurement_supply2_v5_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_left_fan_speed_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_left_fan_speed_measurement_t *src_p,
    size_t size)
{
    uint32_t fan_speed;
    uint32_t voltage_percentage;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&voltage_percentage, &src_p->voltage_percentage, sizeof(voltage_percentage));
    dst_p[0] |= pack_left_shift_u32(voltage_percentage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(voltage_percentage, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(voltage_percentage, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(voltage_percentage, 24u, 0xffu);
    memcpy(&fan_speed, &src_p->fan_speed, sizeof(fan_speed));
    dst_p[4] |= pack_left_shift_u32(fan_speed, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(fan_speed, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(fan_speed, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(fan_speed, 24u, 0xffu);

    return (8);
}

int motor_can_left_fan_speed_measurement_unpack(
    struct motor_can_left_fan_speed_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t fan_speed;
    uint32_t voltage_percentage;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    voltage_percentage = 0u;
    voltage_percentage |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    voltage_percentage |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    voltage_percentage |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    voltage_percentage |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->voltage_percentage, &voltage_percentage, sizeof(dst_p->voltage_percentage));
    fan_speed = 0u;
    fan_speed |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    fan_speed |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    fan_speed |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    fan_speed |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->fan_speed, &fan_speed, sizeof(dst_p->fan_speed));

    return (0);
}

float motor_can_left_fan_speed_measurement_voltage_percentage_encode(double value)
{
    return (float)(value);
}

double motor_can_left_fan_speed_measurement_voltage_percentage_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_fan_speed_measurement_voltage_percentage_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_left_fan_speed_measurement_fan_speed_encode(double value)
{
    return (float)(value);
}

double motor_can_left_fan_speed_measurement_fan_speed_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_fan_speed_measurement_fan_speed_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_left_sink_motor_temp_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_left_sink_motor_temp_measurement_t *src_p,
    size_t size)
{
    uint32_t heatsink_temp;
    uint32_t motor_temp;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&motor_temp, &src_p->motor_temp, sizeof(motor_temp));
    dst_p[0] |= pack_left_shift_u32(motor_temp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(motor_temp, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(motor_temp, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(motor_temp, 24u, 0xffu);
    memcpy(&heatsink_temp, &src_p->heatsink_temp, sizeof(heatsink_temp));
    dst_p[4] |= pack_left_shift_u32(heatsink_temp, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(heatsink_temp, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(heatsink_temp, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(heatsink_temp, 24u, 0xffu);

    return (8);
}

int motor_can_left_sink_motor_temp_measurement_unpack(
    struct motor_can_left_sink_motor_temp_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t heatsink_temp;
    uint32_t motor_temp;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    motor_temp = 0u;
    motor_temp |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    motor_temp |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    motor_temp |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    motor_temp |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->motor_temp, &motor_temp, sizeof(dst_p->motor_temp));
    heatsink_temp = 0u;
    heatsink_temp |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    heatsink_temp |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    heatsink_temp |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    heatsink_temp |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->heatsink_temp, &heatsink_temp, sizeof(dst_p->heatsink_temp));

    return (0);
}

float motor_can_left_sink_motor_temp_measurement_motor_temp_encode(double value)
{
    return (float)(value);
}

double motor_can_left_sink_motor_temp_measurement_motor_temp_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_sink_motor_temp_measurement_motor_temp_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_left_sink_motor_temp_measurement_heatsink_temp_encode(double value)
{
    return (float)(value);
}

double motor_can_left_sink_motor_temp_measurement_heatsink_temp_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_sink_motor_temp_measurement_heatsink_temp_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_left_air_in_cpu_temp_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_left_air_in_cpu_temp_measurement_t *src_p,
    size_t size)
{
    uint32_t air_inlet_temp;
    uint32_t processor_temp;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&processor_temp, &src_p->processor_temp, sizeof(processor_temp));
    dst_p[0] |= pack_left_shift_u32(processor_temp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(processor_temp, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(processor_temp, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(processor_temp, 24u, 0xffu);
    memcpy(&air_inlet_temp, &src_p->air_inlet_temp, sizeof(air_inlet_temp));
    dst_p[4] |= pack_left_shift_u32(air_inlet_temp, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(air_inlet_temp, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(air_inlet_temp, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(air_inlet_temp, 24u, 0xffu);

    return (8);
}

int motor_can_left_air_in_cpu_temp_measurement_unpack(
    struct motor_can_left_air_in_cpu_temp_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t air_inlet_temp;
    uint32_t processor_temp;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    processor_temp = 0u;
    processor_temp |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    processor_temp |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    processor_temp |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    processor_temp |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->processor_temp, &processor_temp, sizeof(dst_p->processor_temp));
    air_inlet_temp = 0u;
    air_inlet_temp |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    air_inlet_temp |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    air_inlet_temp |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    air_inlet_temp |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->air_inlet_temp, &air_inlet_temp, sizeof(dst_p->air_inlet_temp));

    return (0);
}

float motor_can_left_air_in_cpu_temp_measurement_processor_temp_encode(double value)
{
    return (float)(value);
}

double motor_can_left_air_in_cpu_temp_measurement_processor_temp_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_air_in_cpu_temp_measurement_processor_temp_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_left_air_in_cpu_temp_measurement_air_inlet_temp_encode(double value)
{
    return (float)(value);
}

double motor_can_left_air_in_cpu_temp_measurement_air_inlet_temp_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_air_in_cpu_temp_measurement_air_inlet_temp_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_left_air_out_cap_temp_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_left_air_out_cap_temp_measurement_t *src_p,
    size_t size)
{
    uint32_t air_out_temp;
    uint32_t capacitor_temp;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&capacitor_temp, &src_p->capacitor_temp, sizeof(capacitor_temp));
    dst_p[0] |= pack_left_shift_u32(capacitor_temp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(capacitor_temp, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(capacitor_temp, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(capacitor_temp, 24u, 0xffu);
    memcpy(&air_out_temp, &src_p->air_out_temp, sizeof(air_out_temp));
    dst_p[4] |= pack_left_shift_u32(air_out_temp, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(air_out_temp, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(air_out_temp, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(air_out_temp, 24u, 0xffu);

    return (8);
}

int motor_can_left_air_out_cap_temp_measurement_unpack(
    struct motor_can_left_air_out_cap_temp_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t air_out_temp;
    uint32_t capacitor_temp;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    capacitor_temp = 0u;
    capacitor_temp |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    capacitor_temp |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    capacitor_temp |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    capacitor_temp |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->capacitor_temp, &capacitor_temp, sizeof(dst_p->capacitor_temp));
    air_out_temp = 0u;
    air_out_temp |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    air_out_temp |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    air_out_temp |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    air_out_temp |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->air_out_temp, &air_out_temp, sizeof(dst_p->air_out_temp));

    return (0);
}

float motor_can_left_air_out_cap_temp_measurement_capacitor_temp_encode(double value)
{
    return (float)(value);
}

double motor_can_left_air_out_cap_temp_measurement_capacitor_temp_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_air_out_cap_temp_measurement_capacitor_temp_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_left_air_out_cap_temp_measurement_air_out_temp_encode(double value)
{
    return (float)(value);
}

double motor_can_left_air_out_cap_temp_measurement_air_out_temp_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_air_out_cap_temp_measurement_air_out_temp_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_left_odometer_bus_ah_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_left_odometer_bus_ah_measurement_t *src_p,
    size_t size)
{
    uint32_t dc_bus;
    uint32_t odometer;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&odometer, &src_p->odometer, sizeof(odometer));
    dst_p[0] |= pack_left_shift_u32(odometer, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(odometer, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(odometer, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(odometer, 24u, 0xffu);
    memcpy(&dc_bus, &src_p->dc_bus, sizeof(dc_bus));
    dst_p[4] |= pack_left_shift_u32(dc_bus, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(dc_bus, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(dc_bus, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(dc_bus, 24u, 0xffu);

    return (8);
}

int motor_can_left_odometer_bus_ah_measurement_unpack(
    struct motor_can_left_odometer_bus_ah_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t dc_bus;
    uint32_t odometer;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    odometer = 0u;
    odometer |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    odometer |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    odometer |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    odometer |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->odometer, &odometer, sizeof(dst_p->odometer));
    dc_bus = 0u;
    dc_bus |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dc_bus |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dc_bus |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dc_bus |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->dc_bus, &dc_bus, sizeof(dst_p->dc_bus));

    return (0);
}

float motor_can_left_odometer_bus_ah_measurement_odometer_encode(double value)
{
    return (float)(value);
}

double motor_can_left_odometer_bus_ah_measurement_odometer_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_odometer_bus_ah_measurement_odometer_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_left_odometer_bus_ah_measurement_dc_bus_encode(double value)
{
    return (float)(value);
}

double motor_can_left_odometer_bus_ah_measurement_dc_bus_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_odometer_bus_ah_measurement_dc_bus_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_right_id_info_pack(
    uint8_t *dst_p,
    const struct motor_can_right_id_info_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u32(src_p->tritium_id, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->tritium_id, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->tritium_id, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->tritium_id, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u32(src_p->serial_number, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(src_p->serial_number, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(src_p->serial_number, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(src_p->serial_number, 24u, 0xffu);

    return (8);
}

int motor_can_right_id_info_unpack(
    struct motor_can_right_id_info_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->tritium_id |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->tritium_id |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->tritium_id |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->tritium_id |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    dst_p->serial_number |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dst_p->serial_number |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dst_p->serial_number |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dst_p->serial_number |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);

    return (0);
}

uint32_t motor_can_right_id_info_tritium_id_encode(double value)
{
    return (uint32_t)(value);
}

double motor_can_right_id_info_tritium_id_decode(uint32_t value)
{
    return ((double)value);
}

bool motor_can_right_id_info_tritium_id_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

uint32_t motor_can_right_id_info_serial_number_encode(double value)
{
    return (uint32_t)(value);
}

double motor_can_right_id_info_serial_number_decode(uint32_t value)
{
    return ((double)value);
}

bool motor_can_right_id_info_serial_number_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}

int motor_can_right_status_pack(
    uint8_t *dst_p,
    const struct motor_can_right_status_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->limit_flag_bridge_pwm, 0u, 0x01u);
    dst_p[0] |= pack_left_shift_u8(src_p->limit_flag_motor_current, 1u, 0x02u);
    dst_p[0] |= pack_left_shift_u8(src_p->limit_flag_velocity, 2u, 0x04u);
    dst_p[0] |= pack_left_shift_u8(src_p->limit_flag_bus_current, 3u, 0x08u);
    dst_p[0] |= pack_left_shift_u8(src_p->limit_flag_bus_voltage_upper_limit, 4u, 0x10u);
    dst_p[0] |= pack_left_shift_u8(src_p->limit_flag_bus_voltage_lower_limit, 5u, 0x20u);
    dst_p[0] |= pack_left_shift_u8(src_p->limit_flag_heatsink_temperature, 6u, 0x40u);
    dst_p[2] |= pack_left_shift_u8(src_p->error_flag_hw_overcurrent, 0u, 0x01u);
    dst_p[2] |= pack_left_shift_u8(src_p->error_flag_sw_overcurrent, 1u, 0x02u);
    dst_p[2] |= pack_left_shift_u8(src_p->error_flag_dc_bus_overvoltage, 2u, 0x04u);
    dst_p[2] |= pack_left_shift_u8(src_p->error_flag_motor_position_hall_sequence, 3u, 0x08u);
    dst_p[2] |= pack_left_shift_u8(src_p->error_flag_watchdog, 4u, 0x10u);
    dst_p[2] |= pack_left_shift_u8(src_p->error_flag_config_read, 5u, 0x20u);
    dst_p[2] |= pack_left_shift_u8(src_p->error_flag15_v_undervoltage, 6u, 0x40u);
    dst_p[4] |= pack_left_shift_u16(src_p->active_motor, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->active_motor, 8u, 0xffu);

    return (8);
}

int motor_can_right_status_unpack(
    struct motor_can_right_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->limit_flag_bridge_pwm |= unpack_right_shift_u8(src_p[0], 0u, 0x01u);
    dst_p->limit_flag_motor_current |= unpack_right_shift_u8(src_p[0], 1u, 0x02u);
    dst_p->limit_flag_velocity |= unpack_right_shift_u8(src_p[0], 2u, 0x04u);
    dst_p->limit_flag_bus_current |= unpack_right_shift_u8(src_p[0], 3u, 0x08u);
    dst_p->limit_flag_bus_voltage_upper_limit |= unpack_right_shift_u8(src_p[0], 4u, 0x10u);
    dst_p->limit_flag_bus_voltage_lower_limit |= unpack_right_shift_u8(src_p[0], 5u, 0x20u);
    dst_p->limit_flag_heatsink_temperature |= unpack_right_shift_u8(src_p[0], 6u, 0x40u);
    dst_p->error_flag_hw_overcurrent |= unpack_right_shift_u8(src_p[2], 0u, 0x01u);
    dst_p->error_flag_sw_overcurrent |= unpack_right_shift_u8(src_p[2], 1u, 0x02u);
    dst_p->error_flag_dc_bus_overvoltage |= unpack_right_shift_u8(src_p[2], 2u, 0x04u);
    dst_p->error_flag_motor_position_hall_sequence |= unpack_right_shift_u8(src_p[2], 3u, 0x08u);
    dst_p->error_flag_watchdog |= unpack_right_shift_u8(src_p[2], 4u, 0x10u);
    dst_p->error_flag_config_read |= unpack_right_shift_u8(src_p[2], 5u, 0x20u);
    dst_p->error_flag15_v_undervoltage |= unpack_right_shift_u8(src_p[2], 6u, 0x40u);
    dst_p->active_motor |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->active_motor |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);

    return (0);
}

uint8_t motor_can_right_status_limit_flag_bridge_pwm_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_right_status_limit_flag_bridge_pwm_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_right_status_limit_flag_bridge_pwm_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_right_status_limit_flag_motor_current_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_right_status_limit_flag_motor_current_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_right_status_limit_flag_motor_current_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_right_status_limit_flag_velocity_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_right_status_limit_flag_velocity_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_right_status_limit_flag_velocity_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_right_status_limit_flag_bus_current_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_right_status_limit_flag_bus_current_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_right_status_limit_flag_bus_current_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_right_status_limit_flag_bus_voltage_upper_limit_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_right_status_limit_flag_bus_voltage_upper_limit_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_right_status_limit_flag_bus_voltage_upper_limit_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_right_status_limit_flag_bus_voltage_lower_limit_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_right_status_limit_flag_bus_voltage_lower_limit_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_right_status_limit_flag_bus_voltage_lower_limit_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_right_status_limit_flag_heatsink_temperature_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_right_status_limit_flag_heatsink_temperature_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_right_status_limit_flag_heatsink_temperature_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_right_status_error_flag_hw_overcurrent_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_right_status_error_flag_hw_overcurrent_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_right_status_error_flag_hw_overcurrent_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_right_status_error_flag_sw_overcurrent_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_right_status_error_flag_sw_overcurrent_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_right_status_error_flag_sw_overcurrent_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_right_status_error_flag_dc_bus_overvoltage_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_right_status_error_flag_dc_bus_overvoltage_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_right_status_error_flag_dc_bus_overvoltage_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_right_status_error_flag_motor_position_hall_sequence_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_right_status_error_flag_motor_position_hall_sequence_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_right_status_error_flag_motor_position_hall_sequence_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_right_status_error_flag_watchdog_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_right_status_error_flag_watchdog_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_right_status_error_flag_watchdog_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_right_status_error_flag_config_read_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_right_status_error_flag_config_read_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_right_status_error_flag_config_read_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t motor_can_right_status_error_flag15_v_undervoltage_encode(double value)
{
    return (uint8_t)(value);
}

double motor_can_right_status_error_flag15_v_undervoltage_decode(uint8_t value)
{
    return ((double)value);
}

bool motor_can_right_status_error_flag15_v_undervoltage_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint16_t motor_can_right_status_active_motor_encode(double value)
{
    return (uint16_t)(value);
}

double motor_can_right_status_active_motor_decode(uint16_t value)
{
    return ((double)value);
}

bool motor_can_right_status_active_motor_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int motor_can_right_bus_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_right_bus_measurement_t *src_p,
    size_t size)
{
    uint32_t bus_current;
    uint32_t bus_voltage;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&bus_voltage, &src_p->bus_voltage, sizeof(bus_voltage));
    dst_p[0] |= pack_left_shift_u32(bus_voltage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(bus_voltage, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(bus_voltage, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(bus_voltage, 24u, 0xffu);
    memcpy(&bus_current, &src_p->bus_current, sizeof(bus_current));
    dst_p[4] |= pack_left_shift_u32(bus_current, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(bus_current, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(bus_current, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(bus_current, 24u, 0xffu);

    return (8);
}

int motor_can_right_bus_measurement_unpack(
    struct motor_can_right_bus_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t bus_current;
    uint32_t bus_voltage;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    bus_voltage = 0u;
    bus_voltage |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    bus_voltage |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    bus_voltage |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    bus_voltage |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->bus_voltage, &bus_voltage, sizeof(dst_p->bus_voltage));
    bus_current = 0u;
    bus_current |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    bus_current |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    bus_current |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    bus_current |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->bus_current, &bus_current, sizeof(dst_p->bus_current));

    return (0);
}

float motor_can_right_bus_measurement_bus_voltage_encode(double value)
{
    return (float)(value);
}

double motor_can_right_bus_measurement_bus_voltage_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_bus_measurement_bus_voltage_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_right_bus_measurement_bus_current_encode(double value)
{
    return (float)(value);
}

double motor_can_right_bus_measurement_bus_current_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_bus_measurement_bus_current_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_right_velocity_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_right_velocity_measurement_t *src_p,
    size_t size)
{
    uint32_t motor_velocity;
    uint32_t vehicle_velocity;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&motor_velocity, &src_p->motor_velocity, sizeof(motor_velocity));
    dst_p[0] |= pack_left_shift_u32(motor_velocity, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(motor_velocity, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(motor_velocity, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(motor_velocity, 24u, 0xffu);
    memcpy(&vehicle_velocity, &src_p->vehicle_velocity, sizeof(vehicle_velocity));
    dst_p[4] |= pack_left_shift_u32(vehicle_velocity, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(vehicle_velocity, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(vehicle_velocity, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(vehicle_velocity, 24u, 0xffu);

    return (8);
}

int motor_can_right_velocity_measurement_unpack(
    struct motor_can_right_velocity_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t motor_velocity;
    uint32_t vehicle_velocity;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    motor_velocity = 0u;
    motor_velocity |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    motor_velocity |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    motor_velocity |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    motor_velocity |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->motor_velocity, &motor_velocity, sizeof(dst_p->motor_velocity));
    vehicle_velocity = 0u;
    vehicle_velocity |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    vehicle_velocity |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    vehicle_velocity |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    vehicle_velocity |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->vehicle_velocity, &vehicle_velocity, sizeof(dst_p->vehicle_velocity));

    return (0);
}

float motor_can_right_velocity_measurement_motor_velocity_encode(double value)
{
    return (float)(value);
}

double motor_can_right_velocity_measurement_motor_velocity_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_velocity_measurement_motor_velocity_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_right_velocity_measurement_vehicle_velocity_encode(double value)
{
    return (float)(value);
}

double motor_can_right_velocity_measurement_vehicle_velocity_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_velocity_measurement_vehicle_velocity_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_right_phase_current_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_right_phase_current_measurement_t *src_p,
    size_t size)
{
    uint32_t phase_current_a;
    uint32_t phase_current_b;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&phase_current_b, &src_p->phase_current_b, sizeof(phase_current_b));
    dst_p[0] |= pack_left_shift_u32(phase_current_b, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(phase_current_b, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(phase_current_b, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(phase_current_b, 24u, 0xffu);
    memcpy(&phase_current_a, &src_p->phase_current_a, sizeof(phase_current_a));
    dst_p[4] |= pack_left_shift_u32(phase_current_a, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(phase_current_a, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(phase_current_a, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(phase_current_a, 24u, 0xffu);

    return (8);
}

int motor_can_right_phase_current_measurement_unpack(
    struct motor_can_right_phase_current_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t phase_current_a;
    uint32_t phase_current_b;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    phase_current_b = 0u;
    phase_current_b |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    phase_current_b |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    phase_current_b |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    phase_current_b |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->phase_current_b, &phase_current_b, sizeof(dst_p->phase_current_b));
    phase_current_a = 0u;
    phase_current_a |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    phase_current_a |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    phase_current_a |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    phase_current_a |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->phase_current_a, &phase_current_a, sizeof(dst_p->phase_current_a));

    return (0);
}

float motor_can_right_phase_current_measurement_phase_current_b_encode(double value)
{
    return (float)(value);
}

double motor_can_right_phase_current_measurement_phase_current_b_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_phase_current_measurement_phase_current_b_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_right_phase_current_measurement_phase_current_a_encode(double value)
{
    return (float)(value);
}

double motor_can_right_phase_current_measurement_phase_current_a_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_phase_current_measurement_phase_current_a_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_right_motor_voltage_vector_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_right_motor_voltage_vector_measurement_t *src_p,
    size_t size)
{
    uint32_t vd;
    uint32_t vq;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&vq, &src_p->vq, sizeof(vq));
    dst_p[0] |= pack_left_shift_u32(vq, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(vq, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(vq, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(vq, 24u, 0xffu);
    memcpy(&vd, &src_p->vd, sizeof(vd));
    dst_p[4] |= pack_left_shift_u32(vd, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(vd, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(vd, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(vd, 24u, 0xffu);

    return (8);
}

int motor_can_right_motor_voltage_vector_measurement_unpack(
    struct motor_can_right_motor_voltage_vector_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t vd;
    uint32_t vq;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    vq = 0u;
    vq |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    vq |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    vq |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    vq |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->vq, &vq, sizeof(dst_p->vq));
    vd = 0u;
    vd |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    vd |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    vd |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    vd |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->vd, &vd, sizeof(dst_p->vd));

    return (0);
}

float motor_can_right_motor_voltage_vector_measurement_vq_encode(double value)
{
    return (float)(value);
}

double motor_can_right_motor_voltage_vector_measurement_vq_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_motor_voltage_vector_measurement_vq_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_right_motor_voltage_vector_measurement_vd_encode(double value)
{
    return (float)(value);
}

double motor_can_right_motor_voltage_vector_measurement_vd_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_motor_voltage_vector_measurement_vd_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_right_motor_current_vector_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_right_motor_current_vector_measurement_t *src_p,
    size_t size)
{
    uint32_t id;
    uint32_t iq;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&iq, &src_p->iq, sizeof(iq));
    dst_p[0] |= pack_left_shift_u32(iq, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(iq, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(iq, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(iq, 24u, 0xffu);
    memcpy(&id, &src_p->id, sizeof(id));
    dst_p[4] |= pack_left_shift_u32(id, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(id, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(id, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(id, 24u, 0xffu);

    return (8);
}

int motor_can_right_motor_current_vector_measurement_unpack(
    struct motor_can_right_motor_current_vector_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t id;
    uint32_t iq;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    iq = 0u;
    iq |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    iq |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    iq |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    iq |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->iq, &iq, sizeof(dst_p->iq));
    id = 0u;
    id |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    id |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    id |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    id |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->id, &id, sizeof(dst_p->id));

    return (0);
}

float motor_can_right_motor_current_vector_measurement_iq_encode(double value)
{
    return (float)(value);
}

double motor_can_right_motor_current_vector_measurement_iq_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_motor_current_vector_measurement_iq_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_right_motor_current_vector_measurement_id_encode(double value)
{
    return (float)(value);
}

double motor_can_right_motor_current_vector_measurement_id_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_motor_current_vector_measurement_id_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_right_motor_back_emf_measurement_prediction_pack(
    uint8_t *dst_p,
    const struct motor_can_right_motor_back_emf_measurement_prediction_t *src_p,
    size_t size)
{
    uint32_t bem_fd;
    uint32_t bem_fq;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&bem_fq, &src_p->bem_fq, sizeof(bem_fq));
    dst_p[0] |= pack_left_shift_u32(bem_fq, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(bem_fq, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(bem_fq, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(bem_fq, 24u, 0xffu);
    memcpy(&bem_fd, &src_p->bem_fd, sizeof(bem_fd));
    dst_p[4] |= pack_left_shift_u32(bem_fd, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(bem_fd, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(bem_fd, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(bem_fd, 24u, 0xffu);

    return (8);
}

int motor_can_right_motor_back_emf_measurement_prediction_unpack(
    struct motor_can_right_motor_back_emf_measurement_prediction_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t bem_fd;
    uint32_t bem_fq;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    bem_fq = 0u;
    bem_fq |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    bem_fq |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    bem_fq |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    bem_fq |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->bem_fq, &bem_fq, sizeof(dst_p->bem_fq));
    bem_fd = 0u;
    bem_fd |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    bem_fd |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    bem_fd |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    bem_fd |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->bem_fd, &bem_fd, sizeof(dst_p->bem_fd));

    return (0);
}

float motor_can_right_motor_back_emf_measurement_prediction_bem_fq_encode(double value)
{
    return (float)(value);
}

double motor_can_right_motor_back_emf_measurement_prediction_bem_fq_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_motor_back_emf_measurement_prediction_bem_fq_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_right_motor_back_emf_measurement_prediction_bem_fd_encode(double value)
{
    return (float)(value);
}

double motor_can_right_motor_back_emf_measurement_prediction_bem_fd_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_motor_back_emf_measurement_prediction_bem_fd_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_right_voltage_rail15_v1_v65_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_right_voltage_rail15_v1_v65_measurement_t *src_p,
    size_t size)
{
    uint32_t reference1_v65;
    uint32_t supply15_v;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&reference1_v65, &src_p->reference1_v65, sizeof(reference1_v65));
    dst_p[0] |= pack_left_shift_u32(reference1_v65, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(reference1_v65, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(reference1_v65, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(reference1_v65, 24u, 0xffu);
    memcpy(&supply15_v, &src_p->supply15_v, sizeof(supply15_v));
    dst_p[4] |= pack_left_shift_u32(supply15_v, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(supply15_v, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(supply15_v, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(supply15_v, 24u, 0xffu);

    return (8);
}

int motor_can_right_voltage_rail15_v1_v65_measurement_unpack(
    struct motor_can_right_voltage_rail15_v1_v65_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t reference1_v65;
    uint32_t supply15_v;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    reference1_v65 = 0u;
    reference1_v65 |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    reference1_v65 |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    reference1_v65 |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    reference1_v65 |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->reference1_v65, &reference1_v65, sizeof(dst_p->reference1_v65));
    supply15_v = 0u;
    supply15_v |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    supply15_v |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    supply15_v |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    supply15_v |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->supply15_v, &supply15_v, sizeof(dst_p->supply15_v));

    return (0);
}

float motor_can_right_voltage_rail15_v1_v65_measurement_reference1_v65_encode(double value)
{
    return (float)(value);
}

double motor_can_right_voltage_rail15_v1_v65_measurement_reference1_v65_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_voltage_rail15_v1_v65_measurement_reference1_v65_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_right_voltage_rail15_v1_v65_measurement_supply15_v_encode(double value)
{
    return (float)(value);
}

double motor_can_right_voltage_rail15_v1_v65_measurement_supply15_v_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_voltage_rail15_v1_v65_measurement_supply15_v_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_right_voltage_rail2_v51_v2_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_right_voltage_rail2_v51_v2_measurement_t *src_p,
    size_t size)
{
    uint32_t supply1_v2;
    uint32_t supply2_v5;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&supply1_v2, &src_p->supply1_v2, sizeof(supply1_v2));
    dst_p[0] |= pack_left_shift_u32(supply1_v2, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(supply1_v2, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(supply1_v2, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(supply1_v2, 24u, 0xffu);
    memcpy(&supply2_v5, &src_p->supply2_v5, sizeof(supply2_v5));
    dst_p[4] |= pack_left_shift_u32(supply2_v5, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(supply2_v5, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(supply2_v5, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(supply2_v5, 24u, 0xffu);

    return (8);
}

int motor_can_right_voltage_rail2_v51_v2_measurement_unpack(
    struct motor_can_right_voltage_rail2_v51_v2_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t supply1_v2;
    uint32_t supply2_v5;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    supply1_v2 = 0u;
    supply1_v2 |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    supply1_v2 |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    supply1_v2 |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    supply1_v2 |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->supply1_v2, &supply1_v2, sizeof(dst_p->supply1_v2));
    supply2_v5 = 0u;
    supply2_v5 |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    supply2_v5 |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    supply2_v5 |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    supply2_v5 |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->supply2_v5, &supply2_v5, sizeof(dst_p->supply2_v5));

    return (0);
}

float motor_can_right_voltage_rail2_v51_v2_measurement_supply1_v2_encode(double value)
{
    return (float)(value);
}

double motor_can_right_voltage_rail2_v51_v2_measurement_supply1_v2_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_voltage_rail2_v51_v2_measurement_supply1_v2_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_right_voltage_rail2_v51_v2_measurement_supply2_v5_encode(double value)
{
    return (float)(value);
}

double motor_can_right_voltage_rail2_v51_v2_measurement_supply2_v5_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_voltage_rail2_v51_v2_measurement_supply2_v5_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_right_fan_speed_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_right_fan_speed_measurement_t *src_p,
    size_t size)
{
    uint32_t fan_speed;
    uint32_t voltage_percentage;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&voltage_percentage, &src_p->voltage_percentage, sizeof(voltage_percentage));
    dst_p[0] |= pack_left_shift_u32(voltage_percentage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(voltage_percentage, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(voltage_percentage, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(voltage_percentage, 24u, 0xffu);
    memcpy(&fan_speed, &src_p->fan_speed, sizeof(fan_speed));
    dst_p[4] |= pack_left_shift_u32(fan_speed, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(fan_speed, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(fan_speed, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(fan_speed, 24u, 0xffu);

    return (8);
}

int motor_can_right_fan_speed_measurement_unpack(
    struct motor_can_right_fan_speed_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t fan_speed;
    uint32_t voltage_percentage;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    voltage_percentage = 0u;
    voltage_percentage |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    voltage_percentage |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    voltage_percentage |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    voltage_percentage |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->voltage_percentage, &voltage_percentage, sizeof(dst_p->voltage_percentage));
    fan_speed = 0u;
    fan_speed |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    fan_speed |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    fan_speed |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    fan_speed |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->fan_speed, &fan_speed, sizeof(dst_p->fan_speed));

    return (0);
}

float motor_can_right_fan_speed_measurement_voltage_percentage_encode(double value)
{
    return (float)(value);
}

double motor_can_right_fan_speed_measurement_voltage_percentage_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_fan_speed_measurement_voltage_percentage_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_right_fan_speed_measurement_fan_speed_encode(double value)
{
    return (float)(value);
}

double motor_can_right_fan_speed_measurement_fan_speed_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_fan_speed_measurement_fan_speed_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_right_sink_motor_temp_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_right_sink_motor_temp_measurement_t *src_p,
    size_t size)
{
    uint32_t heatsink_temp;
    uint32_t motor_temp;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&motor_temp, &src_p->motor_temp, sizeof(motor_temp));
    dst_p[0] |= pack_left_shift_u32(motor_temp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(motor_temp, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(motor_temp, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(motor_temp, 24u, 0xffu);
    memcpy(&heatsink_temp, &src_p->heatsink_temp, sizeof(heatsink_temp));
    dst_p[4] |= pack_left_shift_u32(heatsink_temp, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(heatsink_temp, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(heatsink_temp, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(heatsink_temp, 24u, 0xffu);

    return (8);
}

int motor_can_right_sink_motor_temp_measurement_unpack(
    struct motor_can_right_sink_motor_temp_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t heatsink_temp;
    uint32_t motor_temp;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    motor_temp = 0u;
    motor_temp |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    motor_temp |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    motor_temp |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    motor_temp |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->motor_temp, &motor_temp, sizeof(dst_p->motor_temp));
    heatsink_temp = 0u;
    heatsink_temp |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    heatsink_temp |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    heatsink_temp |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    heatsink_temp |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->heatsink_temp, &heatsink_temp, sizeof(dst_p->heatsink_temp));

    return (0);
}

float motor_can_right_sink_motor_temp_measurement_motor_temp_encode(double value)
{
    return (float)(value);
}

double motor_can_right_sink_motor_temp_measurement_motor_temp_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_sink_motor_temp_measurement_motor_temp_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_right_sink_motor_temp_measurement_heatsink_temp_encode(double value)
{
    return (float)(value);
}

double motor_can_right_sink_motor_temp_measurement_heatsink_temp_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_sink_motor_temp_measurement_heatsink_temp_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_right_air_in_cpu_temp_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_right_air_in_cpu_temp_measurement_t *src_p,
    size_t size)
{
    uint32_t air_inlet_temp;
    uint32_t processor_temp;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&processor_temp, &src_p->processor_temp, sizeof(processor_temp));
    dst_p[0] |= pack_left_shift_u32(processor_temp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(processor_temp, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(processor_temp, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(processor_temp, 24u, 0xffu);
    memcpy(&air_inlet_temp, &src_p->air_inlet_temp, sizeof(air_inlet_temp));
    dst_p[4] |= pack_left_shift_u32(air_inlet_temp, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(air_inlet_temp, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(air_inlet_temp, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(air_inlet_temp, 24u, 0xffu);

    return (8);
}

int motor_can_right_air_in_cpu_temp_measurement_unpack(
    struct motor_can_right_air_in_cpu_temp_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t air_inlet_temp;
    uint32_t processor_temp;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    processor_temp = 0u;
    processor_temp |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    processor_temp |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    processor_temp |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    processor_temp |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->processor_temp, &processor_temp, sizeof(dst_p->processor_temp));
    air_inlet_temp = 0u;
    air_inlet_temp |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    air_inlet_temp |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    air_inlet_temp |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    air_inlet_temp |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->air_inlet_temp, &air_inlet_temp, sizeof(dst_p->air_inlet_temp));

    return (0);
}

float motor_can_right_air_in_cpu_temp_measurement_processor_temp_encode(double value)
{
    return (float)(value);
}

double motor_can_right_air_in_cpu_temp_measurement_processor_temp_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_air_in_cpu_temp_measurement_processor_temp_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_right_air_in_cpu_temp_measurement_air_inlet_temp_encode(double value)
{
    return (float)(value);
}

double motor_can_right_air_in_cpu_temp_measurement_air_inlet_temp_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_air_in_cpu_temp_measurement_air_inlet_temp_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_right_air_out_cap_temp_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_right_air_out_cap_temp_measurement_t *src_p,
    size_t size)
{
    uint32_t air_out_temp;
    uint32_t capacitor_temp;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&capacitor_temp, &src_p->capacitor_temp, sizeof(capacitor_temp));
    dst_p[0] |= pack_left_shift_u32(capacitor_temp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(capacitor_temp, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(capacitor_temp, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(capacitor_temp, 24u, 0xffu);
    memcpy(&air_out_temp, &src_p->air_out_temp, sizeof(air_out_temp));
    dst_p[4] |= pack_left_shift_u32(air_out_temp, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(air_out_temp, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(air_out_temp, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(air_out_temp, 24u, 0xffu);

    return (8);
}

int motor_can_right_air_out_cap_temp_measurement_unpack(
    struct motor_can_right_air_out_cap_temp_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t air_out_temp;
    uint32_t capacitor_temp;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    capacitor_temp = 0u;
    capacitor_temp |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    capacitor_temp |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    capacitor_temp |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    capacitor_temp |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->capacitor_temp, &capacitor_temp, sizeof(dst_p->capacitor_temp));
    air_out_temp = 0u;
    air_out_temp |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    air_out_temp |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    air_out_temp |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    air_out_temp |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->air_out_temp, &air_out_temp, sizeof(dst_p->air_out_temp));

    return (0);
}

float motor_can_right_air_out_cap_temp_measurement_capacitor_temp_encode(double value)
{
    return (float)(value);
}

double motor_can_right_air_out_cap_temp_measurement_capacitor_temp_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_air_out_cap_temp_measurement_capacitor_temp_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_right_air_out_cap_temp_measurement_air_out_temp_encode(double value)
{
    return (float)(value);
}

double motor_can_right_air_out_cap_temp_measurement_air_out_temp_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_air_out_cap_temp_measurement_air_out_temp_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_right_odometer_bus_ah_measurement_pack(
    uint8_t *dst_p,
    const struct motor_can_right_odometer_bus_ah_measurement_t *src_p,
    size_t size)
{
    uint32_t dc_bus;
    uint32_t odometer;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&odometer, &src_p->odometer, sizeof(odometer));
    dst_p[0] |= pack_left_shift_u32(odometer, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(odometer, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(odometer, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(odometer, 24u, 0xffu);
    memcpy(&dc_bus, &src_p->dc_bus, sizeof(dc_bus));
    dst_p[4] |= pack_left_shift_u32(dc_bus, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(dc_bus, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(dc_bus, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(dc_bus, 24u, 0xffu);

    return (8);
}

int motor_can_right_odometer_bus_ah_measurement_unpack(
    struct motor_can_right_odometer_bus_ah_measurement_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t dc_bus;
    uint32_t odometer;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    odometer = 0u;
    odometer |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    odometer |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    odometer |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    odometer |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->odometer, &odometer, sizeof(dst_p->odometer));
    dc_bus = 0u;
    dc_bus |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    dc_bus |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    dc_bus |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    dc_bus |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->dc_bus, &dc_bus, sizeof(dst_p->dc_bus));

    return (0);
}

float motor_can_right_odometer_bus_ah_measurement_odometer_encode(double value)
{
    return (float)(value);
}

double motor_can_right_odometer_bus_ah_measurement_odometer_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_odometer_bus_ah_measurement_odometer_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_right_odometer_bus_ah_measurement_dc_bus_encode(double value)
{
    return (float)(value);
}

double motor_can_right_odometer_bus_ah_measurement_dc_bus_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_odometer_bus_ah_measurement_dc_bus_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_left_drive_command_pack(
    uint8_t *dst_p,
    const struct motor_can_left_drive_command_t *src_p,
    size_t size)
{
    uint32_t motor_current;
    uint32_t motor_velocity;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&motor_velocity, &src_p->motor_velocity, sizeof(motor_velocity));
    dst_p[0] |= pack_left_shift_u32(motor_velocity, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(motor_velocity, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(motor_velocity, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(motor_velocity, 24u, 0xffu);
    memcpy(&motor_current, &src_p->motor_current, sizeof(motor_current));
    dst_p[4] |= pack_left_shift_u32(motor_current, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(motor_current, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(motor_current, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(motor_current, 24u, 0xffu);

    return (8);
}

int motor_can_left_drive_command_unpack(
    struct motor_can_left_drive_command_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t motor_current;
    uint32_t motor_velocity;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    motor_velocity = 0u;
    motor_velocity |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    motor_velocity |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    motor_velocity |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    motor_velocity |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->motor_velocity, &motor_velocity, sizeof(dst_p->motor_velocity));
    motor_current = 0u;
    motor_current |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    motor_current |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    motor_current |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    motor_current |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->motor_current, &motor_current, sizeof(dst_p->motor_current));

    return (0);
}

float motor_can_left_drive_command_motor_velocity_encode(double value)
{
    return (float)(value);
}

double motor_can_left_drive_command_motor_velocity_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_drive_command_motor_velocity_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_left_drive_command_motor_current_encode(double value)
{
    return (float)(value);
}

double motor_can_left_drive_command_motor_current_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_drive_command_motor_current_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_left_motor_power_command_pack(
    uint8_t *dst_p,
    const struct motor_can_left_motor_power_command_t *src_p,
    size_t size)
{
    uint32_t bus_current;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&bus_current, &src_p->bus_current, sizeof(bus_current));
    dst_p[4] |= pack_left_shift_u32(bus_current, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(bus_current, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(bus_current, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(bus_current, 24u, 0xffu);

    return (8);
}

int motor_can_left_motor_power_command_unpack(
    struct motor_can_left_motor_power_command_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t bus_current;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    bus_current = 0u;
    bus_current |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    bus_current |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    bus_current |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    bus_current |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->bus_current, &bus_current, sizeof(dst_p->bus_current));

    return (0);
}

float motor_can_left_motor_power_command_bus_current_encode(double value)
{
    return (float)(value);
}

double motor_can_left_motor_power_command_bus_current_decode(float value)
{
    return ((double)value);
}

bool motor_can_left_motor_power_command_bus_current_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_left_reset_command_pack(
    uint8_t *dst_p,
    const struct motor_can_left_reset_command_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    return (8);
}

int motor_can_left_reset_command_unpack(
    struct motor_can_left_reset_command_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    return (0);
}

int motor_can_right_drive_command_pack(
    uint8_t *dst_p,
    const struct motor_can_right_drive_command_t *src_p,
    size_t size)
{
    uint32_t motor_current;
    uint32_t motor_velocity;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&motor_velocity, &src_p->motor_velocity, sizeof(motor_velocity));
    dst_p[0] |= pack_left_shift_u32(motor_velocity, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(motor_velocity, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(motor_velocity, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(motor_velocity, 24u, 0xffu);
    memcpy(&motor_current, &src_p->motor_current, sizeof(motor_current));
    dst_p[4] |= pack_left_shift_u32(motor_current, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(motor_current, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(motor_current, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(motor_current, 24u, 0xffu);

    return (8);
}

int motor_can_right_drive_command_unpack(
    struct motor_can_right_drive_command_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t motor_current;
    uint32_t motor_velocity;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    motor_velocity = 0u;
    motor_velocity |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    motor_velocity |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    motor_velocity |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    motor_velocity |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->motor_velocity, &motor_velocity, sizeof(dst_p->motor_velocity));
    motor_current = 0u;
    motor_current |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    motor_current |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    motor_current |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    motor_current |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->motor_current, &motor_current, sizeof(dst_p->motor_current));

    return (0);
}

float motor_can_right_drive_command_motor_velocity_encode(double value)
{
    return (float)(value);
}

double motor_can_right_drive_command_motor_velocity_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_drive_command_motor_velocity_is_in_range(float value)
{
    (void)value;

    return (true);
}

float motor_can_right_drive_command_motor_current_encode(double value)
{
    return (float)(value);
}

double motor_can_right_drive_command_motor_current_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_drive_command_motor_current_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_right_motor_power_command_pack(
    uint8_t *dst_p,
    const struct motor_can_right_motor_power_command_t *src_p,
    size_t size)
{
    uint32_t bus_current;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&bus_current, &src_p->bus_current, sizeof(bus_current));
    dst_p[4] |= pack_left_shift_u32(bus_current, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(bus_current, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(bus_current, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(bus_current, 24u, 0xffu);

    return (8);
}

int motor_can_right_motor_power_command_unpack(
    struct motor_can_right_motor_power_command_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t bus_current;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    bus_current = 0u;
    bus_current |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    bus_current |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    bus_current |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    bus_current |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->bus_current, &bus_current, sizeof(dst_p->bus_current));

    return (0);
}

float motor_can_right_motor_power_command_bus_current_encode(double value)
{
    return (float)(value);
}

double motor_can_right_motor_power_command_bus_current_decode(float value)
{
    return ((double)value);
}

bool motor_can_right_motor_power_command_bus_current_is_in_range(float value)
{
    (void)value;

    return (true);
}

int motor_can_right_reset_command_pack(
    uint8_t *dst_p,
    const struct motor_can_right_reset_command_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    return (8);
}

int motor_can_right_reset_command_unpack(
    struct motor_can_right_reset_command_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    return (0);
}
